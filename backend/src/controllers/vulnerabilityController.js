const Vulnerability = require('../models/Vulnerability');
const Device = require('../models/Device');
const Alert = require('../models/Alert');
const emailService = require('../services/emailService');
const logger = require('../utils/logger');
const { validationResult } = require('express-validator');

class VulnerabilityController {
  // Get all vulnerabilities with filtering and pagination
  async getAllVulnerabilities(req, res) {
    try {
      const {
        page = 1,
        limit = 20,
        severity,
        department,
        status,
        search,
        sortBy = 'publishedDate',
        sortOrder = 'desc'
      } = req.query;

      // Build filter object
      const filter = {};
      
      if (severity) filter.severity = severity;
      if (department) filter.department = department;
      if (status) filter.status = status;
      
      if (search) {
        filter.$or = [
          { cveId: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
          { oem: { $regex: search, $options: 'i' } },
          { 'affectedDevices.deviceName': { $regex: search, $options: 'i' } }
        ];
      }

      // Build sort object
      const sort = {};
      sort[sortBy] = sortOrder === 'desc' ? -1 : 1;

      // Execute query with pagination
      const vulnerabilities = await Vulnerability.find(filter)
        .populate('affectedDevices.deviceId', 'name model manufacturer location')
        .populate('assignedTo', 'name email department')
        .sort(sort)
        .limit(limit * 1)
        .skip((page - 1) * limit)
        .lean();

      // Get total count for pagination
      const total = await Vulnerability.countDocuments(filter);

      // Calculate statistics
      const stats = await this.getVulnerabilityStats(filter);

      res.json({
        success: true,
        data: {
          vulnerabilities,
          pagination: {
            current: parseInt(page),
            pages: Math.ceil(total / limit),
            total,
            limit: parseInt(limit)
          },
          stats
        }
      });
    } catch (error) {
      logger.error('Error fetching vulnerabilities:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch vulnerabilities',
        error: error.message
      });
    }
  }

  // Get vulnerability by ID
  async getVulnerabilityById(req, res) {
    try {
      const { id } = req.params;
      
      const vulnerability = await Vulnerability.findById(id)
        .populate('affectedDevices.deviceId')
        .populate('assignedTo', 'name email department role')
        .populate('mitigationStatus.riskAcceptedBy', 'name email');

      if (!vulnerability) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }

      res.json({
        success: true,
        data: vulnerability
      });
    } catch (error) {
      logger.error('Error fetching vulnerability:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch vulnerability',
        error: error.message
      });
    }
  }

  // Create new vulnerability
  async createVulnerability(req, res) {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation errors',
          errors: errors.array()
        });
      }

      const vulnerabilityData = req.body;
      
      // Check if CVE already exists
      const existingVuln = await Vulnerability.findOne({ cveId: vulnerabilityData.cveId });
      if (existingVuln) {
        return res.status(409).json({
          success: false,
          message: 'Vulnerability with this CVE ID already exists'
        });
      }

      // Create vulnerability
      const vulnerability = new Vulnerability(vulnerabilityData);
      await vulnerability.save();

      // Create alert if severity is critical or high
      if (vulnerability.severity === 'critical' || vulnerability.severity === 'high') {
        await this.createVulnerabilityAlert(vulnerability);
      }

      // Send email notifications for critical vulnerabilities
      if (vulnerability.severity === 'critical' || vulnerability.patientSafetyImpact === 'life-critical') {
        await this.sendVulnerabilityNotifications(vulnerability);
      }

      res.status(201).json({
        success: true,
        message: 'Vulnerability created successfully',
        data: vulnerability
      });
    } catch (error) {
      logger.error('Error creating vulnerability:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create vulnerability',
        error: error.message
      });
    }
  }

  // Update vulnerability
  async updateVulnerability(req, res) {
    try {
      const { id } = req.params;
      const updates = req.body;

      const vulnerability = await Vulnerability.findByIdAndUpdate(
        id,
        { ...updates, lastModifiedDate: new Date() },
        { new: true, runValidators: true }
      ).populate('assignedTo', 'name email');

      if (!vulnerability) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }

      res.json({
        success: true,
        message: 'Vulnerability updated successfully',
        data: vulnerability
      });
    } catch (error) {
      logger.error('Error updating vulnerability:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update vulnerability',
        error: error.message
      });
    }
  }

  // Delete vulnerability
  async deleteVulnerability(req, res) {
    try {
      const { id } = req.params;

      const vulnerability = await Vulnerability.findByIdAndDelete(id);
      if (!vulnerability) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }

      // Also delete related alerts
      await Alert.deleteMany({ 'source.identifier': vulnerability.cveId });

      res.json({
        success: true,
        message: 'Vulnerability deleted successfully'
      });
    } catch (error) {
      logger.error('Error deleting vulnerability:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete vulnerability',
        error: error.message
      });
    }
  }

  // Get vulnerability statistics
  async getVulnerabilityStats(filter = {}) {
    try {
      const stats = await Vulnerability.aggregate([
        { $match: filter },
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            critical: { $sum: { $cond: [{ $eq: ['$severity', 'critical'] }, 1, 0] } },
            high: { $sum: { $cond: [{ $eq: ['$severity', 'high'] }, 1, 0] } },
            medium: { $sum: { $cond: [{ $eq: ['$severity', 'medium'] }, 1, 0] } },
            low: { $sum: { $cond: [{ $eq: ['$severity', 'low'] }, 1, 0] } },
            lifeCritical: { $sum: { $cond: [{ $eq: ['$patientSafetyImpact', 'life-critical'] }, 1, 0] } },
            avgCvssScore: { $avg: '$cvssScore' },
            newThisWeek: {
              $sum: {
                $cond: [
                  { $gte: ['$discoveredDate', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)] },
                  1,
                  0
                ]
              }
            }
          }
        }
      ]);

      return stats[0] || {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        lifeCritical: 0,
        avgCvssScore: 0,
        newThisWeek: 0
      };
    } catch (error) {
      logger.error('Error calculating vulnerability stats:', error);
      return {};
    }
  }

  // Create alert for vulnerability
  async createVulnerabilityAlert(vulnerability) {
    try {
      const alert = new Alert({
        title: `${vulnerability.severity.toUpperCase()} Vulnerability Detected`,
        message: `${vulnerability.cveId}: ${vulnerability.description.substring(0, 200)}...`,
        type: 'vulnerability',
        severity: vulnerability.severity,
        priority: vulnerability.severity === 'critical' ? 'immediate' : 'urgent',
        source: {
          type: 'vulnerability_scanner',
          identifier: vulnerability.cveId,
          details: {
            cvssScore: vulnerability.cvssScore,
            patientSafetyImpact: vulnerability.patientSafetyImpact
          }
        },
        department: vulnerability.department,
        patientSafetyImpact: vulnerability.patientSafetyImpact,
        hipaaImpact: vulnerability.hipaaRisk,
        assignedTo: vulnerability.assignedTo
      });

      await alert.save();
      logger.info(`Alert created for vulnerability ${vulnerability.cveId}`);
    } catch (error) {
      logger.error('Error creating vulnerability alert:', error);
    }
  }

  // Send vulnerability notifications
  async sendVulnerabilityNotifications(vulnerability) {
    try {
      const recipients = process.env.ALERT_EMAIL_RECIPIENTS?.split(',') || [];
      
      if (recipients.length > 0) {
        const result = await emailService.sendVulnerabilityAlert(vulnerability, recipients);
        
        // Update vulnerability with notification status
        await Vulnerability.findByIdAndUpdate(vulnerability._id, {
          $push: {
            alertsSent: {
              type: 'email',
              recipients,
              status: result.success ? 'sent' : 'failed',
              sentAt: new Date()
            }
          }
        });
      }
    } catch (error) {
      logger.error('Error sending vulnerability notifications:', error);
    }
  }

  // Get vulnerability trends
  async getVulnerabilityTrends(req, res) {
    try {
      const { days = 30 } = req.query;
      const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

      const trends = await Vulnerability.aggregate([
        {
          $match: {
            discoveredDate: { $gte: startDate }
          }
        },
        {
          $group: {
            _id: {
              date: { $dateToString: { format: '%Y-%m-%d', date: '$discoveredDate' } },
              severity: '$severity'
            },
            count: { $sum: 1 }
          }
        },
        {
          $group: {
            _id: '$_id.date',
            severities: {
              $push: {
                severity: '$_id.severity',
                count: '$count'
              }
            },
            total: { $sum: '$count' }
          }
        },
        { $sort: { _id: 1 } }
      ]);

      res.json({
        success: true,
        data: trends
      });
    } catch (error) {
      logger.error('Error fetching vulnerability trends:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch vulnerability trends',
        error: error.message
      });
    }
  }

  // Bulk update vulnerabilities
  async bulkUpdateVulnerabilities(req, res) {
    try {
      const { ids, updates } = req.body;

      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Invalid or empty vulnerability IDs array'
        });
      }

      const result = await Vulnerability.updateMany(
        { _id: { $in: ids } },
        { ...updates, lastModifiedDate: new Date() }
      );

      res.json({
        success: true,
        message: `${result.modifiedCount} vulnerabilities updated successfully`,
        data: {
          matched: result.matchedCount,
          modified: result.modifiedCount
        }
      });
    } catch (error) {
      logger.error('Error bulk updating vulnerabilities:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to bulk update vulnerabilities',
        error: error.message
      });
    }
  }
}

module.exports = new VulnerabilityController();